/* 
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

package com.formance.formance_sdk.models.shared;

import com.fasterxml.jackson.annotation.JsonCreator;
import com.fasterxml.jackson.annotation.JsonFormat;
import com.fasterxml.jackson.annotation.JsonIgnore;
import com.fasterxml.jackson.annotation.JsonInclude.Include;
import com.fasterxml.jackson.annotation.JsonInclude;
import com.fasterxml.jackson.annotation.JsonProperty;
import com.fasterxml.jackson.core.type.TypeReference;
import com.fasterxml.jackson.databind.annotation.JsonDeserialize;
import com.fasterxml.jackson.databind.annotation.JsonSerialize;
import com.formance.formance_sdk.utils.Utils;
import java.io.InputStream;
import java.lang.Deprecated;
import java.math.BigDecimal;
import java.math.BigInteger;
import java.time.OffsetDateTime;
import java.util.Optional;

public class Payment {

    @JsonProperty("adjustments")
    private java.util.List<PaymentAdjustment> adjustments;

    @JsonProperty("amount")
    private BigInteger amount;

    @JsonProperty("asset")
    private String asset;

    @JsonProperty("connectorID")
    private String connectorID;

    @JsonProperty("createdAt")
    private OffsetDateTime createdAt;

    @JsonProperty("destinationAccountID")
    private String destinationAccountID;

    @JsonProperty("id")
    private String id;

    @JsonProperty("initialAmount")
    private BigInteger initialAmount;

    @JsonInclude(Include.ALWAYS)
    @JsonProperty("metadata")
    private Optional<? extends java.util.Map<String, String>> metadata;

    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("provider")
    private Optional<? extends Connector> provider;

    @JsonInclude(Include.ALWAYS)
    @JsonProperty("raw")
    private Optional<? extends Raw> raw;

    @JsonProperty("reference")
    private String reference;

    @JsonProperty("scheme")
    private PaymentScheme scheme;

    @JsonProperty("sourceAccountID")
    private String sourceAccountID;

    @JsonProperty("status")
    private PaymentStatus status;

    @JsonProperty("type")
    private PaymentType type;

    @JsonCreator
    public Payment(
            @JsonProperty("adjustments") java.util.List<PaymentAdjustment> adjustments,
            @JsonProperty("amount") BigInteger amount,
            @JsonProperty("asset") String asset,
            @JsonProperty("connectorID") String connectorID,
            @JsonProperty("createdAt") OffsetDateTime createdAt,
            @JsonProperty("destinationAccountID") String destinationAccountID,
            @JsonProperty("id") String id,
            @JsonProperty("initialAmount") BigInteger initialAmount,
            @JsonProperty("metadata") Optional<? extends java.util.Map<String, String>> metadata,
            @JsonProperty("provider") Optional<? extends Connector> provider,
            @JsonProperty("raw") Optional<? extends Raw> raw,
            @JsonProperty("reference") String reference,
            @JsonProperty("scheme") PaymentScheme scheme,
            @JsonProperty("sourceAccountID") String sourceAccountID,
            @JsonProperty("status") PaymentStatus status,
            @JsonProperty("type") PaymentType type) {
        Utils.checkNotNull(adjustments, "adjustments");
        Utils.checkNotNull(amount, "amount");
        Utils.checkNotNull(asset, "asset");
        Utils.checkNotNull(connectorID, "connectorID");
        Utils.checkNotNull(createdAt, "createdAt");
        Utils.checkNotNull(destinationAccountID, "destinationAccountID");
        Utils.checkNotNull(id, "id");
        Utils.checkNotNull(initialAmount, "initialAmount");
        Utils.checkNotNull(metadata, "metadata");
        Utils.checkNotNull(provider, "provider");
        Utils.checkNotNull(raw, "raw");
        Utils.checkNotNull(reference, "reference");
        Utils.checkNotNull(scheme, "scheme");
        Utils.checkNotNull(sourceAccountID, "sourceAccountID");
        Utils.checkNotNull(status, "status");
        Utils.checkNotNull(type, "type");
        this.adjustments = adjustments;
        this.amount = amount;
        this.asset = asset;
        this.connectorID = connectorID;
        this.createdAt = createdAt;
        this.destinationAccountID = destinationAccountID;
        this.id = id;
        this.initialAmount = initialAmount;
        this.metadata = metadata;
        this.provider = provider;
        this.raw = raw;
        this.reference = reference;
        this.scheme = scheme;
        this.sourceAccountID = sourceAccountID;
        this.status = status;
        this.type = type;
    }
    
    public Payment(
            java.util.List<PaymentAdjustment> adjustments,
            BigInteger amount,
            String asset,
            String connectorID,
            OffsetDateTime createdAt,
            String destinationAccountID,
            String id,
            BigInteger initialAmount,
            String reference,
            PaymentScheme scheme,
            String sourceAccountID,
            PaymentStatus status,
            PaymentType type) {
        this(adjustments, amount, asset, connectorID, createdAt, destinationAccountID, id, initialAmount, Optional.empty(), Optional.empty(), Optional.empty(), reference, scheme, sourceAccountID, status, type);
    }

    @JsonIgnore
    public java.util.List<PaymentAdjustment> adjustments() {
        return adjustments;
    }

    @JsonIgnore
    public BigInteger amount() {
        return amount;
    }

    @JsonIgnore
    public String asset() {
        return asset;
    }

    @JsonIgnore
    public String connectorID() {
        return connectorID;
    }

    @JsonIgnore
    public OffsetDateTime createdAt() {
        return createdAt;
    }

    @JsonIgnore
    public String destinationAccountID() {
        return destinationAccountID;
    }

    @JsonIgnore
    public String id() {
        return id;
    }

    @JsonIgnore
    public BigInteger initialAmount() {
        return initialAmount;
    }

    @SuppressWarnings("unchecked")
    @JsonIgnore
    public Optional<java.util.Map<String, String>> metadata() {
        return (Optional<java.util.Map<String, String>>) metadata;
    }

    @SuppressWarnings("unchecked")
    @JsonIgnore
    public Optional<Connector> provider() {
        return (Optional<Connector>) provider;
    }

    @SuppressWarnings("unchecked")
    @JsonIgnore
    public Optional<Raw> raw() {
        return (Optional<Raw>) raw;
    }

    @JsonIgnore
    public String reference() {
        return reference;
    }

    @JsonIgnore
    public PaymentScheme scheme() {
        return scheme;
    }

    @JsonIgnore
    public String sourceAccountID() {
        return sourceAccountID;
    }

    @JsonIgnore
    public PaymentStatus status() {
        return status;
    }

    @JsonIgnore
    public PaymentType type() {
        return type;
    }

    public final static Builder builder() {
        return new Builder();
    }

    public Payment withAdjustments(java.util.List<PaymentAdjustment> adjustments) {
        Utils.checkNotNull(adjustments, "adjustments");
        this.adjustments = adjustments;
        return this;
    }

    public Payment withAmount(long amount) {
        this.amount = BigInteger.valueOf(amount);
        return this;
    }

    public Payment withAmount(BigInteger amount) {
        Utils.checkNotNull(amount, "amount");
        this.amount = amount;
        return this;
    }

    public Payment withAsset(String asset) {
        Utils.checkNotNull(asset, "asset");
        this.asset = asset;
        return this;
    }

    public Payment withConnectorID(String connectorID) {
        Utils.checkNotNull(connectorID, "connectorID");
        this.connectorID = connectorID;
        return this;
    }

    public Payment withCreatedAt(OffsetDateTime createdAt) {
        Utils.checkNotNull(createdAt, "createdAt");
        this.createdAt = createdAt;
        return this;
    }

    public Payment withDestinationAccountID(String destinationAccountID) {
        Utils.checkNotNull(destinationAccountID, "destinationAccountID");
        this.destinationAccountID = destinationAccountID;
        return this;
    }

    public Payment withId(String id) {
        Utils.checkNotNull(id, "id");
        this.id = id;
        return this;
    }

    public Payment withInitialAmount(long initialAmount) {
        this.initialAmount = BigInteger.valueOf(initialAmount);
        return this;
    }

    public Payment withInitialAmount(BigInteger initialAmount) {
        Utils.checkNotNull(initialAmount, "initialAmount");
        this.initialAmount = initialAmount;
        return this;
    }

    public Payment withMetadata(java.util.Map<String, String> metadata) {
        Utils.checkNotNull(metadata, "metadata");
        this.metadata = Optional.ofNullable(metadata);
        return this;
    }

    public Payment withMetadata(Optional<? extends java.util.Map<String, String>> metadata) {
        Utils.checkNotNull(metadata, "metadata");
        this.metadata = metadata;
        return this;
    }

    public Payment withProvider(Connector provider) {
        Utils.checkNotNull(provider, "provider");
        this.provider = Optional.ofNullable(provider);
        return this;
    }

    public Payment withProvider(Optional<? extends Connector> provider) {
        Utils.checkNotNull(provider, "provider");
        this.provider = provider;
        return this;
    }

    public Payment withRaw(Raw raw) {
        Utils.checkNotNull(raw, "raw");
        this.raw = Optional.ofNullable(raw);
        return this;
    }

    public Payment withRaw(Optional<? extends Raw> raw) {
        Utils.checkNotNull(raw, "raw");
        this.raw = raw;
        return this;
    }

    public Payment withReference(String reference) {
        Utils.checkNotNull(reference, "reference");
        this.reference = reference;
        return this;
    }

    public Payment withScheme(PaymentScheme scheme) {
        Utils.checkNotNull(scheme, "scheme");
        this.scheme = scheme;
        return this;
    }

    public Payment withSourceAccountID(String sourceAccountID) {
        Utils.checkNotNull(sourceAccountID, "sourceAccountID");
        this.sourceAccountID = sourceAccountID;
        return this;
    }

    public Payment withStatus(PaymentStatus status) {
        Utils.checkNotNull(status, "status");
        this.status = status;
        return this;
    }

    public Payment withType(PaymentType type) {
        Utils.checkNotNull(type, "type");
        this.type = type;
        return this;
    }
    
    @Override
    public boolean equals(java.lang.Object o) {
        if (this == o) {
            return true;
        }
        if (o == null || getClass() != o.getClass()) {
            return false;
        }
        Payment other = (Payment) o;
        return 
            java.util.Objects.deepEquals(this.adjustments, other.adjustments) &&
            java.util.Objects.deepEquals(this.amount, other.amount) &&
            java.util.Objects.deepEquals(this.asset, other.asset) &&
            java.util.Objects.deepEquals(this.connectorID, other.connectorID) &&
            java.util.Objects.deepEquals(this.createdAt, other.createdAt) &&
            java.util.Objects.deepEquals(this.destinationAccountID, other.destinationAccountID) &&
            java.util.Objects.deepEquals(this.id, other.id) &&
            java.util.Objects.deepEquals(this.initialAmount, other.initialAmount) &&
            java.util.Objects.deepEquals(this.metadata, other.metadata) &&
            java.util.Objects.deepEquals(this.provider, other.provider) &&
            java.util.Objects.deepEquals(this.raw, other.raw) &&
            java.util.Objects.deepEquals(this.reference, other.reference) &&
            java.util.Objects.deepEquals(this.scheme, other.scheme) &&
            java.util.Objects.deepEquals(this.sourceAccountID, other.sourceAccountID) &&
            java.util.Objects.deepEquals(this.status, other.status) &&
            java.util.Objects.deepEquals(this.type, other.type);
    }
    
    @Override
    public int hashCode() {
        return java.util.Objects.hash(
            adjustments,
            amount,
            asset,
            connectorID,
            createdAt,
            destinationAccountID,
            id,
            initialAmount,
            metadata,
            provider,
            raw,
            reference,
            scheme,
            sourceAccountID,
            status,
            type);
    }
    
    @Override
    public String toString() {
        return Utils.toString(Payment.class,
                "adjustments", adjustments,
                "amount", amount,
                "asset", asset,
                "connectorID", connectorID,
                "createdAt", createdAt,
                "destinationAccountID", destinationAccountID,
                "id", id,
                "initialAmount", initialAmount,
                "metadata", metadata,
                "provider", provider,
                "raw", raw,
                "reference", reference,
                "scheme", scheme,
                "sourceAccountID", sourceAccountID,
                "status", status,
                "type", type);
    }
    
    public final static class Builder {
 
        private java.util.List<PaymentAdjustment> adjustments;
 
        private BigInteger amount;
 
        private String asset;
 
        private String connectorID;
 
        private OffsetDateTime createdAt;
 
        private String destinationAccountID;
 
        private String id;
 
        private BigInteger initialAmount;
 
        private Optional<? extends java.util.Map<String, String>> metadata = Optional.empty();
 
        private Optional<? extends Connector> provider = Optional.empty();
 
        private Optional<? extends Raw> raw = Optional.empty();
 
        private String reference;
 
        private PaymentScheme scheme;
 
        private String sourceAccountID;
 
        private PaymentStatus status;
 
        private PaymentType type;  
        
        private Builder() {
          // force use of static builder() method
        }

        public Builder adjustments(java.util.List<PaymentAdjustment> adjustments) {
            Utils.checkNotNull(adjustments, "adjustments");
            this.adjustments = adjustments;
            return this;
        }

        public Builder amount(long amount) {
            this.amount = BigInteger.valueOf(amount);
            return this;
        }

        public Builder amount(BigInteger amount) {
            Utils.checkNotNull(amount, "amount");
            this.amount = amount;
            return this;
        }

        public Builder asset(String asset) {
            Utils.checkNotNull(asset, "asset");
            this.asset = asset;
            return this;
        }

        public Builder connectorID(String connectorID) {
            Utils.checkNotNull(connectorID, "connectorID");
            this.connectorID = connectorID;
            return this;
        }

        public Builder createdAt(OffsetDateTime createdAt) {
            Utils.checkNotNull(createdAt, "createdAt");
            this.createdAt = createdAt;
            return this;
        }

        public Builder destinationAccountID(String destinationAccountID) {
            Utils.checkNotNull(destinationAccountID, "destinationAccountID");
            this.destinationAccountID = destinationAccountID;
            return this;
        }

        public Builder id(String id) {
            Utils.checkNotNull(id, "id");
            this.id = id;
            return this;
        }

        public Builder initialAmount(long initialAmount) {
            this.initialAmount = BigInteger.valueOf(initialAmount);
            return this;
        }

        public Builder initialAmount(BigInteger initialAmount) {
            Utils.checkNotNull(initialAmount, "initialAmount");
            this.initialAmount = initialAmount;
            return this;
        }

        public Builder metadata(java.util.Map<String, String> metadata) {
            Utils.checkNotNull(metadata, "metadata");
            this.metadata = Optional.ofNullable(metadata);
            return this;
        }

        public Builder metadata(Optional<? extends java.util.Map<String, String>> metadata) {
            Utils.checkNotNull(metadata, "metadata");
            this.metadata = metadata;
            return this;
        }

        public Builder provider(Connector provider) {
            Utils.checkNotNull(provider, "provider");
            this.provider = Optional.ofNullable(provider);
            return this;
        }

        public Builder provider(Optional<? extends Connector> provider) {
            Utils.checkNotNull(provider, "provider");
            this.provider = provider;
            return this;
        }

        public Builder raw(Raw raw) {
            Utils.checkNotNull(raw, "raw");
            this.raw = Optional.ofNullable(raw);
            return this;
        }

        public Builder raw(Optional<? extends Raw> raw) {
            Utils.checkNotNull(raw, "raw");
            this.raw = raw;
            return this;
        }

        public Builder reference(String reference) {
            Utils.checkNotNull(reference, "reference");
            this.reference = reference;
            return this;
        }

        public Builder scheme(PaymentScheme scheme) {
            Utils.checkNotNull(scheme, "scheme");
            this.scheme = scheme;
            return this;
        }

        public Builder sourceAccountID(String sourceAccountID) {
            Utils.checkNotNull(sourceAccountID, "sourceAccountID");
            this.sourceAccountID = sourceAccountID;
            return this;
        }

        public Builder status(PaymentStatus status) {
            Utils.checkNotNull(status, "status");
            this.status = status;
            return this;
        }

        public Builder type(PaymentType type) {
            Utils.checkNotNull(type, "type");
            this.type = type;
            return this;
        }
        
        public Payment build() {
            return new Payment(
                adjustments,
                amount,
                asset,
                connectorID,
                createdAt,
                destinationAccountID,
                id,
                initialAmount,
                metadata,
                provider,
                raw,
                reference,
                scheme,
                sourceAccountID,
                status,
                type);
        }
    }
}

